# x86 Disassembly/Calling Conventions
## 目录
1. 调用约定
2. 术语
3. 标准C语言调用约定
    - 3.1 CDECL
    - 3.2 STDCALL
	- 3.3 FASTCALL
4. C++ 调用约定
    - 4.1 THISCALL
    - 4.2 命名重整(Name Mangling)
	- 4.3 Extern "C"
5. 命名修饰
6. 更多

## *调用约定*

*调用约定*在机器中实现函数调用(Called)时的是一种标准的方法. *调用约定*指定一个编译器设置去
访问函数. 理论上讲,任何编译器编译出来的代码都应该能互连,只有所有的函数都有相同的*调用约定*
但现实上不总是这样.*调用约定*指定了参数如何被传送给函数,返回值如何被返回,函数如何被调用,函
数如何管理栈已经函数自己的栈.简单点,*调用约定*定义了在C或C++一个函数调用如何被翻译成汇编语
言Needless to say, there are many ways for this translation to occur, which is why it's so important to specify certain standard methods. If these standard conventions did not exist, it would be nearly impossible for programs created using different compilers to communicate and interact with one another.

There are three major calling conventions that are used with the C language: STDCALL, CDECL, and FASTCALL. In addition, there is another calling convention typically used with C++: THISCALL. There are other calling conventions as well, including PASCAL and FORTRAN conventions, among others. We will not consider those conventions in this book.

## 术语

There are a few terms that we are going to be using in this chapter, which are mostly common sense, but which are worthy of stating directly:

* 传递参数(Passing arguments)

    "传递参数"是一种说法:把数据放在被调用的函数将会被读的地方. 参数会在函数调用前被传递

* Right-to-Left and Left-to-Right

    描述高级代码参数传递的顺序,例如一下的C语言:

        MyFunction1(a, b);
	Left-to-right 这会生成以下的代码:

        push a
		push b
		call _MyFunction1

    Right-to-right 会生成以下代码

        push b
		push a
		call _MyFunction1
* Return value

    Some functions return a value, and that value must be received reliably by the function's caller. The called function places its return value in a place where the calling function can get it when execution returns. The called function stores the return value before executing the ret instruction.
* Cleaning the stack

    当参数被压入栈,它们最终需要被弹出栈, 调用或者被调用函数有责任清除被压进堆栈的参数

* Calling function (the caller)

    The "parent" function that calls the subroutine. Execution resumes in the calling function directly after the subroutine call, unless the program terminates inside the subroutine.
* Called function (the callee)

    The "child" function that gets called by the "parent."
* 命名修饰(Name Decoration)

    当C代码被翻译成汇编代码,编译器会经常通过在函数名称添加一些额外信息来修饰,让链接器
	使用它们去链接到正确的函数上,对于多数的*调用约定*,修饰非常简单(通常仅仅一个到2个额
	外的标记来表示修饰), 但是在某些极限的例子函数名会严重错位(notably C++ "thiscall" convention)
* Entry sequence (the function prologue)

    在函数开始的时候的一些汇编指令，准备栈指针和寄存器等,一让函数使用
* Exit sequence ( the function epilogue)

    a few instructions at the end of a function, which restore the stack and registers to the state expected by the caller, and return to the caller. Some calling conventions clean the stack in the exit sequence.

* Call sequence

    在数调用者传递参数,调用Called function. 在Called function返回后, 在Call sequence中*调用约定*有一些指令清除栈

## 标准C语言调用约定
C语言缺省使用CDECL*调用约定*, 但是大多数的编译器允许程序员用一个关键字去指定.这个关键字不是ISO-ANSI C standard, 你
必须在使用前阅读编译器的文档关于这一部分.

If a calling convention other than CDECL is to be used, or if CDECL is not the default for your compiler, and you want to manually use it, you must specify the calling convention keyword in the function declaration itself, and in any prototypes for the function. This is important because both the calling function and the called function need to know the calling convention.
* CDECL

    In the CDECL calling convention the following holds:

    * Arguments are passed on the stack in Right-to-Left order, and return values are passed in eax.
    * The calling function cleans the stack. This allows CDECL functions to have variable-length argument
    lists (aka variadic functions). For this reason the number of arguments is not appended to the
	name of the function by the compiler, and the assembler and the linker are therefore unable to
	determine if an incorrect number of arguments is used.

Variadic functions usually have special entry code, generated by the va_start(), va_arg() C pseudo-functions.

Consider the following C instructions:

    _cdecl int MyFunction1(int a,int b)
	{
        return a + b;
    }
and the following function call:

    x = MyFunction1(2,3);
These would produce the following assembly listings, respectively:

    _MyFunction1:           # args frame start= esp+4
	push %ebp               # arg frame start= esp+8
	mov %esp,%ebp
	mov 8($ebp),%eax
	mov 12(%ebp),%edx
	add %eax,%edx
	pop %ebp
	ret
and

    push 3
	push 2
	call _MyFunction1
	add $8,%esp
When translated to assembly code, CDECL functions are almost always prepended with an underscore (that's why all previous examples have used "_" in the assembly code).